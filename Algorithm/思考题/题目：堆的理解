堆的理解
贪心策略

随时找到数据流的中位数
【题目】 有一个源源不断地吐出整数的数据流，
假设你有足够的空间来 保存吐出的数。请设计一个名叫MedianHolder的结构， 
MedianHolder可以随时取得之前吐出所有数的中位数。
【要求】 
1.如果MedianHolder已经保存了吐出的N个数，
  那么任意时刻 将一个新数加入到MedianHolder的过程，其时间复杂度是 O(logN)。 
2.取得已经吐出的N个数整体的中位数的过程，时间复杂度为 O(1)。


解答思路：
建立两个堆，一个大根堆，一个小根堆。
大根堆中放小的数，小根堆中大的数，并且力争两个堆内的数字个数相同，这样小根堆和大根堆的堆顶就是中位数了。
而如何做到让两个堆的数量相同呢？如下：
假设第一个数为5，我们可将其放入小根堆，对于下一个要进来了数，如果他比5小，押入到大根堆中；
如果比5大，则将这个数押入到大根堆中。 但是这样会出现两边个数不平衡，那么我们考察两个堆的size差值是否大于1，
如果大于1，即为2的时候，我们将较多的那个堆的堆定弹出，押入到另一个堆中 。
数字入堆调整的时间代价为O(logN)，取数为o（1）。




题目二
一块金条切成两半，是需要花费和长度数值一样的铜板的。
比如长度为20的 金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金 条，
怎么分最省铜板?

例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为10+20+30=60. 金条要分成10,20,30三个部分。
如果，先把长度60的金条分成10和50，花费60 
再把长度50的金条分成20和30，花费50
一共花费110铜板。
但是如果， 
先把长度60的金条分成30和30，花费60 
再把长度30金条分成10和20，花费30 
一共花费90铜板。
输入一个数组，返回分割的最小代价。


题目思路：
求所有非叶结点的值加起来谁低，哈夫曼编码
将所以的叶结点的数，放入到一个小根堆中，每次弹出两个最小的数，将这两个数相加之后，记录这个和，并将这个和放回到原小根堆，
然后再在小根堆中取出两个数，直到小根堆内的数只有一个为止。



题目三
输入: 参数1，正数数组costs 参数2，正数数组profits 参数3，正数k 参数4，正数m
costs[i]表示i号项目的花费 
profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润) 
k表示你不能并行、只能串行的最多做k个项目 
m表示你初始的资金

说明:你每做完一个项目，马上获得的收益，可以支持你去做下一个 项目。
输出: 你最后获得的最大钱数。

解答思想：

需要建立两个堆，分别为大根堆和小根堆。
因为我们的资金有限，能够做的项目资金小于才可以上马，
所以将项目花费cost作为小根堆的内容排列，
而将项目收益prifits较高的放入到大根堆中，去获得最大收益，
  
第一步，我们将能够上马的，cost满足要求的项目弹出，直到小根堆堆顶的值大于启动资为止。
第二步，将弹出的项目的profits全部押入到大根堆中，在大根堆中找到堆顶的值的项目，
      由此可以获得到最大的收益， 做完这个收益最大的项目之后，初始资金增加.
第三步，因为初始资金的增加，重新在小根堆中查看，弹出满足的项目，在依次进行前面两步。

 






