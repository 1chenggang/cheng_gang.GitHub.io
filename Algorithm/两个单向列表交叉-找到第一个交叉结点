方法1.
hash表的使用
hash表内存放的是内存地址
当遇到内存地址相同的时候找到这个结点

public static Node getFistLoopNode(Node head){
  HashSet<Node> = new HashSet<Node>();
  
  while(head != null){
    if(set.contains(head)){//判断hash表中否有head地址
      return head;
    }
    set.add(head);
    head = head.next;
  }
  return null;
}


快慢指针 时间复杂度o（n）
如果无环，则快指针会为空

如果有环，则快慢指针一定会相遇
相遇后，将快指针回到开头，接下来快指针一次走一步，相遇位置为第一个环结点。
第一步先判断两个链表是否都不为空；
第二步判断链表是否有环，针对无环和有环分别判断
      不会出现一个有一个无还有交点的情况，因为相交就意味着合一了。
code：

public class FindFirstIntersectNode{

  public static class Node{
    public int value;
    public Node next;
    
    public Node(int data){
      this.value = data;
    }
  }
  
  public static Node getIntersectNode(Node head1, Node head2){
   if(head1 == null || head2 ==null){
    return null;
   }
   
   Node loop1 = getLoopNode(head1);
   Node loop2 = getLoopNode(head2);
   
   if(loop1 != null && loop2 != null){
    return noLoop(head1, head2);
   }
   if(loop1 == null && loop2 == null){
    return bothLoop(head1, head2);
   }
   return null;
  }
  
  public static Node getLoopNode(Node head){        //通过快慢指针判断,寻找环
    if(head == null || head.next == null || head.next.next == null){
      return null;
    }
    Node n1 = head.next;//慢
    Node n2 = head.next.next;//快
    while(n1 != n2){
      if(n2.next == null || n2.next.next == null){
        return null;
      }
      //不满足while继续循环

      n2 = n2.next.next;
      n1 = n1.next;
    }
    //当n2走到尾部为空的时候，n2挪到头。
    n2 = head;
    //再次遍历，n2也变成慢指针
    while(n1 != n2){
    n2 = n2.next;
    n1 = n1.next;
    }
    return n1;
  }
  
  public static Node noLoop(Node head1, Node head2){
    if(head1 == null || head2 == null){
      return null;
    }
    Node cur1 = head1;
    Node cur2 = head2;
    //先得到两个链表的长度，n1, n2,在计算出差值作为较长链表开始的位置
    
    int n = 0;
    while(cur1.next != null){
      n++;
      cur1= cur1.next;
    }
    while(cur2.next != null){
      n--;
      cur2= cur2.next;
    }//得到了差值。
    
    
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



}
